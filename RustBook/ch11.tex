\documentclass[cjk,14pt,xcolor=dvipsnames,table,dvipdfmx,professional font,t,fragile]{beamer}
\usetheme{Copenhagen}
\usepackage{ulem}
\usepackage{tabularx}
\usepackage{fancybox}
\usepackage{fancyvrb}
\usepackage{float}
\usepackage{multicol}
\usepackage{minijs}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{minted}
\usepackage{ulem}
\usepackage{newtxtext}
\usepackage{listings, listings-rust}
\usepackage{hyperref}


\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\kanjifamilydefault}{\gtdefault}
%
\hypersetup{
 pdfauthor={小林 克希},
 pdftitle={RustBook勉強会},
 pdfkeywords={Rust},
 pdfsubject={},
 pdfcreator={pLaTeX + dvipdfmx},
 pdflang={Japanese}
}
%
\newenvironment{commandline}%
{\VerbatimEnvironment
  \begin{Sbox}\begin{minipage}{0.9\hsize}\begin{fontsize}{8}{8} \color{white} \begin{BVerbatim}}%
{\end{BVerbatim}\end{fontsize}\end{minipage}\end{Sbox}
  \setlength{\fboxsep}{8pt}
% start on a new paragraph

\vspace{6pt}% skip before
\fcolorbox{white}{black}{\TheSbox}

\vspace{3pt}% skip after
}
%end of commandlinesmall

\begin{document}
\title{RustBook勉強会}
\subtitle{11. Testing}
\author{Katsuki Kobayashi}
\date{2019-02-23}

\maketitle

\begin{frame}{予めお詫び}
 \begin{itemize}
  \item 発表者はC言語/ARMアセンブラのみ書ける
  \item ということで、他の言語とかさっぱりです
	\begin{itemize}
	 \item 「あの言語では〜〜」とかいうのは\\
	       全体に聞いてください
	 \item 不幸にも最近C++の本を読まされています\\
	       タスケテ
	\end{itemize}
  \item 社風:「テスト? なにそれ食べられるの?」
  \item 「世間一般ではこんな感じ」的なツッコミ歓迎
 \end{itemize}
\end{frame}

\begin{frame}{自動テストを書こう!}
 \begin{itemize}
  \item ダイクストラ先生曰く(1972年のエッセイ)
	\begin{itemize}
	 \item 	{\scriptsize
		``Program testing can be very effective way to show the presence of bugs,
		but it is hopelessly inadequate for showing their absence.''}
	 \item バグの存在を示す効果的な方法ではあるが、\\
	       無い事を示すには絶望的に不充分である
	\end{itemize}
  \item でも、「テストを頑張るべきではない」、\\
	という意味ではない
 \end{itemize}
\end{frame}

\begin{frame}{正確さ(correctness)}
 \begin{itemize}
  \item Rustは正確さについてかなり考えられている
	\begin{itemize}
	 \item が、やっぱり正確であることの証明は大変
	\end{itemize}
  \item Rustの型システムはこの重役を担っている
	\begin{itemize}
	 \item が、型だけで不正確を全部抑えられない
	\end{itemize}
  \item というわけで、Rustは言語レベルでの\\
	テストの自動化をサポートします
 \end{itemize}
\end{frame}

\begin{frame}{例: \texttt{add\_two()} (1/2)}
 \begin{itemize}
  \item \texttt{add\_two()}
	\begin{itemize}
	 \item 入力された値に2を加えて返す関数
	 \item 入出力はともに整数
	\end{itemize}
  \item コンパイルするとRustがチェック
	\begin{itemize}
	 \item 型の一致 (Stringを入れたらエラー)
	 \item borrow (変な参照をしたらエラー)
	\end{itemize}
  \item 関数の挙動はノーチェック
	\begin{itemize}
	 \item $10$ 足されようが $50$ 引かれようが\\
	       エラーにはならない
	\end{itemize}
  \item 「自動テスト」の出番
 \end{itemize}
\end{frame}

\begin{frame}{例: \texttt{add\_two()} (2/2)}
 \begin{itemize}
  \item テストの方法の例
	\begin{itemize}
	 \item $3$ を与えたら $5$ を返すとassertをする
	 \item このテストを、コードの変更の度に行なう
	 \item 正しい挙動をしている事を確認
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}{このチャプターは}
 \begin{itemize}
  \item テストは難しいので
	\begin{itemize}
	 \item 良いテストの詳細についてはカバーしない
	 \item Rustののテストのための機能について議論する
	\end{itemize}
  \item 取り扱う内容
	\begin{itemize}
	 \item アノテーション
	 \item マクロ
	 \item デフォルトの挙動
	 \item オプション
	 \item unit testとintegration testの構成方法
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}{How to Write Tests}
 \begin{itemize}
  \item Rustのテスト
	\begin{itemize}
	 \item コードが期待通り動くかを確認するテスト関数
	\end{itemize}
  \item テスト関数では一般に以下の3つのアクションを実行
	\begin{itemize}
	 \item 必要なデータや状態を準備する
	 \item テストしたいコードを実行する
	 \item 結果が期待通りかアサートする
	\end{itemize}
  \item 以降、Rustがテストのために提供しているものを紹介
	\begin{itemize}
	 \item \texttt{test} attribute
	 \item マクロ
	 \item \texttt{should\_panic} attribute、等
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Anatomy of a Test Function(1/7)}
 \begin{itemize}
  \item ぶっちゃけ、Rustのテストとは\\
	\texttt{test} attribute をつけた関数のこと
	\begin{itemize}
	 \item attribute: Chapt. 5で使った \texttt{derive} とか
	\end{itemize}
  \item test attributeの付け方: \\
	\hspace{2zw} \texttt{fn} の前に \verb|#[test]| を付ける
  \item \texttt{test} attributeを付けると
	\begin{itemize}
	 \item \texttt{cargo test}コマンド
	 \item テストランナーをビルドして実行
	 \item レポートを表示 (passes or fails)
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Anatomy of a Test Function(2/7)}
 \begin{itemize}
  \item \verb|cargo new adder --lib| する
 \end{itemize}
 \begin{commandline}
% cargo new adder --lib
      Created library `adder` package
 \end{commandline}
 \begin{itemize}
  \item \texttt{src/libs.rs} が以下の内容で作成される
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}\end{lstlisting}}
 \begin{itemize}
  \item とりあえず \verb|#[cfg(test)]| と \verb|mod tests| の行は無視
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Anatomy of a Test Function(3/7)}
 \mbox{}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}\end{lstlisting}}
 \begin{itemize}
  \item \verb|#[test]|
	\begin{itemize}
	 \item テスト関数を示す
	 \item 共通処理等を書く非テスト関数も書けるように
	\end{itemize}
  \item \verb|assert_eq!(2 + 2, 4)|
	\begin{itemize}
	 \item $2 + 2$ が $4$ である事をアサート
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Anatomy of a Test Function(4/7)}
 \begin{commandline}
% cargo test
   Compiling adder v0.1.0 (/home/rare/work/slides/RustBook/samples/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running target/debug/deps/adder-1d0dfd1494bab5c6

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
 \end{commandline}
 \begin{itemize}
  \item \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=ce8ee04d2dcc2311a14efc8090ebda51}
	{Playground} でもテストできる……
  \item ignored, filteredについては次節で説明
  \item measuredについては現在はnightlyだけの機能
	\begin{itemize}
	 \item ベンチマークテスト用
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Anatomy of a Test Function(5/7)}
 \begin{itemize}
  \item \verb|Doc-tests adder| という出力がある
	\begin{itemize}
	 \item ドキュメントテストの結果
	 \item APIのドキュメントのコーディング例もコンパイル/テスト可能
	 \item ドキュメントとコードの同期に役立つ!!
	\end{itemize}
	\pause
  \item Chapt. 14 ``Documentation Comments'' でやるのでスルーします
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Anatomy of a Test Function(6/7)}
 \begin{itemize}
  \item テストの名前を変更
	\begin{itemize}
	 \item \verb|it_works()| を \verb|exploration()| にしてみる
	 \item  \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=dc15fce8e988e1efd0a2dd8d8d87dd27}
		{Playground}
	 \item 無事に結果の表示に反映
	\end{itemize}
 \end{itemize}
 \begin{commandline}
running 1 test
test tests::exploration ... ok
 \end{commandline}
\end{frame}

\begin{frame}[fragile]{The Anatomy of a Test Function(7/7)}
 \begin{itemize}
  \item 失敗するテストを入れてみる
	\begin{itemize}
	 \item \verb|panic!| マクロを使って \verb|another()| 関数を作る
	 \item \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=71238afa6168ec8b26d4bf761d6404a6}
	       {Playground}
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
    #[test]
    fn another() {
        panic!("Make this test fail");
    }\end{lstlisting}}
 \begin{itemize}
  \item 無事失敗する (前回より2つ項目が増えてる)
 \end{itemize}
 \vspace*{-10pt}
 \begin{commandline}
test tests::another ... FAILED

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at 'Make this test fail!', src/lib.rs:10:9

failures:
    tests::another
 \end{commandline}
\end{frame}

\begin{frame}[fragile]{Checking Results with the assert! (1/5)}
 \begin{itemize}
  \item \verb|assert!| マクロ
	\begin{itemize}
	 \item true: 何もしない
	 \item false: \verb|panic!| をコール
	\end{itemize}
  \item Chapt. 5の \texttt{Rectanble}構造体を例に
	\begin{itemize}
	 \item 	\href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=dc15fce8e988e1efd0a2dd8d8d87dd27}
		{Playground}
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&self, other: &Rectangle) -> bool {
        self.length > other.length && self.width > other.width
    }
}\end{lstlisting}}

\end{frame}

\begin{frame}[fragile]{Checking Results with the assert! (2/5)}
\mbox{}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&self, other: &Rectangle) -> bool {
        self.length > other.length && self.width > other.width
    }
}\end{lstlisting}}
 \begin{itemize}
   \item \verb|can_hold()| メソッド
	 \begin{itemize}
	  \item ブール値を返す\\
		\hspace{3zw} $\rightarrow$ \verb|assert!| でのテストに最適!!
	  \item \verb|length| が $8$ , \verb|width| が $7$ の \verb|Rectangle| が\\
		\verb|length| が $5$ , \verb|width| が $1$ の \verb|Rectangle|
		をholdできる事をテスト
	 \end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Checking Results with the assert! (3/5)}
 \begin{itemize}
  \item \verb|larger_can_hold_smaller()| テスト
	\begin{itemize}
	 \item \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=cdf6bb94826b7c2d369e3419ac251cac}
	       {Playground} (\verb|use super::*;| する必要あり)
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&smaller));
    }\end{lstlisting}}
 \begin{commandline}
running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
 \end{commandline}
 \begin{itemize}
  \item \verb|can_hold(0)| は \texttt{true} を返すのでpassする
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Checking Results with the assert! (4/5)}
 \begin{itemize}
  \item \verb|smaller_cannot_hold_larger()| テスト
	\begin{itemize}
	 \item \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=6eff4f70eba2b909a0cd377e1ebad141}
	       {Playground}
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&larger));  // '!' がミソ
    }\end{lstlisting}}
 \begin{commandline}
running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
 \end{commandline}
 \begin{itemize}
  \item \verb|smaller_cannot_hold_larger()| が \verb|false| を返すのでpassする
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Checking Results with the assert! (5/5)}
 \begin{itemize}
  \item バグを仕込んでみる
	\begin{itemize}
	 \item \texttt{length} の不等号が逆
	 \item \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=67c1f9b79733a2ebeec35d8556b00ca4}
	       {Playground}
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
impl Rectangle {
    pub fn can_hold(&self, other: &Rectangle) -> bool {
        self.length < other.length && self.width > other.width
    } //            ^
}\end{lstlisting}}
\begin{itemize}
 \item 目論見通りfailする
\end{itemize}
\begin{commandline}
running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed: larger.can_hold(&smaller)', src/lib.rs:29:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Testing Equality with the assert\_eq! (1/4)}
 \begin{itemize}
  \item テストの一般的な方法は期待値と結果の比較
	\begin{itemize}
	 \item \verb|assert!| マクロに $==$ を渡してもよい
	 \item \verb|assert_eq!|,  \verb|assert_ne!| マクロもある
	 \item これらは期待値と結果の両方を表示してくれる
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Testing Equality with the assert\_eq! (2/4)}
 \begin{itemize}
  \item \verb|add_two()| による例:
	\href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=3e41a536cc2029885d833562d24c9a30}
	{(Playground)}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
fn main() {}
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}\end{lstlisting}}
\begin{commandline}
test tests::it_adds_two ... ok
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Testing Equality with the assert\_eq! (3/4)}
 \begin{itemize}
  \item 失敗するようにする
	\href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=dfd0a140bf3dcd3168db3debdf3e064b}
	{(Playground)}
 \end{itemize}

 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
fn main() {}
pub fn add_two(a: i32) -> i32 {
    a + 3   // なぜか3 を足す
}\end{lstlisting}}
\begin{commandline}
thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
\end{commandline}
\begin{itemize}
 \item \texttt{left}と\texttt{right}が表示される
       \begin{itemize}
	\item 他の言語やテストフレームワークだと
	      \texttt{expected} と \texttt{actual} と呼んだりする
	\item Rustは期待値と結果の順番を気にしないので
	      \verb|assert_eq!(add_two(2), 4);| としてもOK
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Testing Equality with the assert\_eq! (4/4)}
 \begin{itemize}
  \item \verb|assert_ne!|マクロもある
	\begin{itemize}
	 \item $2$つの値が異なればpass、等しければfail
	 \item 「結果が正確に解らないが特定の値にはならない」
	       というテストに使う
	 \item 例えば、結果が実行する時間によって変化するもの
	\end{itemize}
  \item \verb|assert_eq!|と\verb|assert_ne!|
	\begin{itemize}
	 \item 使用する値には PartialEq と Debugトレイトが実装されている必要がある
	       \begin{itemize}
		\item '$==$' と '$!=$' で比較
		\item 結果をデバッグフォーマットで表示する
	       \end{itemize}
	 \item 独自に実装した構造体やenumについては
	       \verb|#[derive(PartialEq, Debug)]| と付ければ大抵OK
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Adding Custom Failure Messages(1/5)}
 \begin{itemize}
  \item 失敗時のメッセージを追加できる
	\begin{itemize}
	 \item \verb|assert!|, \verb|assert_eq!|, \verb|assert_ne!| マクロの
	       引数の続きに \verb|format!| マクロに渡す引数を付ける
	 \item ``\verb|{}| textholder''を書いて値を表示できる
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Adding Custom Failure Messages(2/5)}
 \begin{itemize}
  \item greet関数による例
	\begin{itemize}
	 \item (\href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=0253d4f4ae81c9de7103a3453bd8290b}
	       {Playground})
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}
\end{lstlisting}}
 \begin{itemize}
  \item 今後の仕様変化への対応のため、出力に引数(名前)が含まれているかでテストしている
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Adding Custom Failure Messages(3/5)}
 \begin{itemize}
  \item 当然、テストは通る
 \end{itemize}
\begin{commandline}
running 1 test
test tests::greeting_contains_name ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
 \begin{itemize}
  \item では、壊しましょう
	\begin{itemize}
	 \item \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=d37ff552d3017ee02fcc5f8e1eb1bcef}
	       {(Playground)}
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
pub fn greeting(_name: &str) -> String {
    String::from("Hello!") // 引数を含まないように
}
\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Adding Custom Failure Messages(4/5)}
 \begin{itemize}
  \item 壊れました
 \end{itemize}
 \begin{commandline}
failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at \
'assertion failed: result.contains("Carol")', src/lib.rs:12:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.
 \end{commandline}
\begin{itemize}
 \item でも
       \begin{itemize}
	\item テストが失敗した\texttt{assert}の内容だけ表示される
	      \begin{itemize}
	       \item \verb|result.contains("Carol")|
	      \end{itemize}
	\item \verb|greeting()| 関数の出力を表示した方が便利
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Adding Custom Failure Messages(5/5)}
 \begin{itemize}
  \item テストを変更する
	\begin{itemize}
	 \item \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=1a0c93fc1cad391ba20a1a70a80efff7}
	       {(Playground)}
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[test]
fn greeting_contains_name() {
    let result = greeting("Carol");
    assert!(
        result.contains("Carol"),
        "Greeting did not contain name, value was `{}`", result
    );
}\end{lstlisting}}
 \begin{commandline}
failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at \
'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.
 \end{commandline}
\end{frame}

\begin{frame}[fragile]{Panic with \texttt{should\_panic} (1/8)}
 \begin{itemize}
  \item 結果が正しいかのチェックだけでなく、
	エラー条件についてのチェックも重要
  \item 例として \texttt{Guess} type(9章)で説明します
	\begin{itemize}
	 \item 構造体のvalueフィールド: $1 \sim 100$
	 \item \verb|new()|メソッドで値が範囲外なpanicする
	\end{itemize}
 \end{itemize}
 {\scriptsize \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
pub struct Guess {
    value: i32,
}
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        Guess {
            value
        }
    }
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Panic with \texttt{should\_panic} (2/8)}
 \begin{itemize}
  \item 範囲外の値を入れてpanicさせるテストを書く
	\begin{itemize}
	 \item attributeを追加する : \verb|should_panic|
	 \item panicしたらpass, しなかったらfail
	 \item \href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=d997d3b4a728cac8457b9bbc650e78bf}
	       {(Playground)}
	\end{itemize}
 \end{itemize}
 \vspace{-.5zw}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]  // 順番は逆でも良い模様
    fn greater_than_100() {
        Guess::new(200);
    }
}\end{lstlisting}}
 \vspace{-.5zw}
\begin{commandline}
running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Panic with \texttt{should\_panic} (3/8)}
 \begin{itemize}
  \item バグを仕込みましょう
	\begin{itemize}
	 \item \href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=69a9efedbdf8007e106163ab5236cf52}
	       {(Playground)}
	\end{itemize}
 \end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 /* 100より大きい条件を消す */ {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        Guess {
            value
        }
    }
}\end{lstlisting}}
\begin{itemize}
 \item 無事に失敗する
\end{itemize}
\begin{commandline}
running 1 test
test tests::greater_than_100 ... FAILED
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Panic with \texttt{should\_panic} (4/8)}
 \begin{commandline}
running 1 test
test tests::greater_than_100 ... FAILED
 \end{commandline}
\begin{itemize}
 \item メッセージが不親切
 \item 加えて、\verb|should_panic|は不正確になりがち
       \begin{itemize}
	\item テストが期待とは異なるpanicを起こしてもpassする
       \end{itemize}
 \item もうちょっと親切かつ正確にするために \verb|expected| パラメーターを
       \verb|should_panic| attributeに追加する
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Panic with \texttt{should\_panic} (5/8)}
 \begin{itemize}
  \item \verb|new()|メソッドを変更
	\begin{itemize}
	 \item 初期値が大きすぎるか、
	       小さすぎるかで、panic時のメッセージを変更する
	\end{itemize}
 \end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
pub fn new(value: i32) -> Guess {
    if value < 1 {
        panic!("Guess value must be greater than or equal to 1, got {}.",
               value);
    } else if value > 100 {
        panic!("Guess value must be less than or equal to 100, got {}.",
               value);
    }
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Panic with \texttt{should\_panic} (6/8)}
 \begin{itemize}
  \item \verb|should_panic| に \verb|expected| パラメータ
	\begin{itemize}
	 \item \href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=498dda42617ff9de462a2edb7ef82a05}
	       {(Playground)}
	 \item panic時のメッセージのsubstringを指定する
	\end{itemize}
 \end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(
        expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}\end{lstlisting}}
\begin{commandline}
running 1 test
test tests::greater_than_100 ... ok
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Panic with \texttt{should\_panic} (7/8)}
 \begin{itemize}
  \item バグを仕込む
	\begin{itemize}
	 \item panicの文言を入れ替えた
	 \item \href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0062381305db283f03f7511fcaabd1c2}
	       {(Playground)}
	\end{itemize}
 \end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
if value < 1 {
    panic!("Guess value must be less than or equal to 100, got {}.",
           value);
} else if value > 100 {
    panic!("Guess value must be greater than or equal to 1, got {}.",
           value);
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Panic with \texttt{should\_panic} (8/8)}
\begin{itemize}
 \item 無事失敗する
       \begin{itemize}
	\item パニックの文言が表示
	\item 表示されるべき文言がnoteに表示
       \end{itemize}
\end{itemize}
\begin{commandline}
failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at \
'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:14:13
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string \
'Guess value must be less than or equal to 100'
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Using \texttt{Result<T,E>} (1/3)}
 \begin{itemize}
  \item ここまで、テストに \verb|panic!| を使ってきた
  \item テストには \verb|Result<T, E>| も使える
	\begin{itemize}
	 \item 先程見た \verb|it_works()| 関数を \verb|Result| で書き換え
	 \item 成功時に \verb|Ok(())| を返し、失敗時に文言を含んだ \verb|Err| を返す
	 \item \href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=774593cbe99583e34456249c55b26116}
	       {(Playground)}
	\end{itemize}
 \end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Using \texttt{Result<T,E>} (2/3)}
 \begin{itemize}
  \item 出力
 \end{itemize}
\begin{commandline}
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}

\begin{itemize}
 \item (追試): $2 + 2$ を $2 + 3$ としたら以下のように
       \begin{itemize}
	\item \verb|assert_eq!| みたいな出力だが
	      \begin{itemize}
	       \item 左辺はエラー結果(非0)の値を意味している模様
	       \item 右辺は成功時の結果(0)
	      \end{itemize}
       \end{itemize}
\end{itemize}
\begin{commandline}
Error: "two plus two does not equal four"
thread 'tests::it_works' panicked at \
'assertion failed: `(left == right)`
  left: `1`,
 right: `0`: the test returned a termination value \
with a non-zero status code (1) which indicates a failure', src/libtest/lib.rs:337:5
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Using \texttt{Result<T,E>} (3/3)}
 \begin{itemize}
  \item この方法を使う場合 \verb|#[should_panic]| は使えない
  \item 替わりに \verb|Err| を返すようにしましょう
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Controlling How Tests Are Run (1/2)}
 \begin{itemize}
  \item \verb|cargo test| コマンド
	\begin{itemize}
	 \item テストモードでコードをコンパイルし実行
	 \item デフォルトでは全てのテストをパラレルで実行し、
	       実行中に生成された出力をキャプチャする
	 \item コマンドラインオプションで挙動を変更できる
	\end{itemize}
  \item オプションは2種類ある
	\begin{itemize}
	 \item \verb|cargo test| へのオプション
	 \item テストバイナリへのオプション
	\end{itemize}
  \item 2種類のオプションはセパレーター ''\verb|--| (ハイフン2つ)`` で分割する
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Controlling How Tests Are Run (2/2)}
\vspace*{-10pt}
\begin{commandline}
% cargo test --help | head
cargo-test
Execute all unit and integration tests of a local package

USAGE:
    cargo test [OPTIONS] [TESTNAME] [-- <args>...]

OPTIONS:
        --lib                       Test only this package's library
        --bin <NAME>...             Test only the specified binary
        --bins                      Test all binaries
% cargo test -- --help | head
   Compiling hello v0.1.0 (/tmp/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/hello-ef71f4ccd46d6561
Usage: --help [OPTIONS] [FILTER]

Options:
        --include-ignored
                        Run ignored and not ignored tests
        --ignored       Run only ignored tests
        --test          Run tests and not benchmarks
        --bench         Run benchmarks instead of tests
        --list          List all tests and benchmarks
    -h, --help          Display this message (longer with --help)
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Running Tests in Parallel or Conse...(1/2)}
 \begin{itemize}
  \item デフォルトでは複数のテストをスレッドで並列実行する
	\begin{itemize}
	 \item フィードバックを高速に受け取れる
	 \item ワークスペースの状態や環境変数に依存していない必要がある
	\end{itemize}
  \item 駄目な例
	\begin{itemize}
	 \item いくつかのテストが text-output.txt にデータを書く
	 \item 各テストがファイルのデータの値によってassertする
	\end{itemize}
  \item 駄目な例の解決方法
	\begin{itemize}
	 \item ファイル名を変更する
	 \item 同時に実行されないようにする
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Running Tests in Parallel or Conse...(2/2)}
 \begin{itemize}
  \item \verb|--test-threads|
	\begin{itemize}
	 \item テストバイナリ用のオプション
	 \item テストに使うスレッドの数を指定
	\end{itemize}
 \end{itemize}
\begin{commandline}
% cargo test -- --test-threads=1
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Showing Function Output(1/5)}
\begin{itemize}
 \item デフォルトではテストがpassした場合標準出力は捨てられる
 \item \verb|println!()| を使った関数での例
\end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
fn prints_and_returns_10(a: i32) -> i32 {
    println!("I got the value {}", a);
    10
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Showing Function Output(2/5)}
\begin{itemize}
 \item テストコード
       \begin{itemize}
	\item \href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=913e7b544d281420871a9dea82522845}
	      {(Playground)} {\tiny ただし、Playgroundではコマンドラインオプションが渡せない……!}
       \end{itemize}
\end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Showing Function Output(3/5)}
 \begin{itemize}
  \item テスト結果 (何もつけない)
	\begin{itemize}
	 \item passしたテストの出力は表示されない
	\end{itemize}
 \end{itemize}
\begin{commandline}
running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:20:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Showing Function Output(4/5)}
 \begin{itemize}
  \item \verb|cargo test -- --nocapture| で実行
	\begin{itemize}
	 \item 成功時の表示も出力される
	 \item テスト出力とテストの結果がインタリーブされてしまう
	       ← 並列実行するため
	\end{itemize}
 \end{itemize}
\begin{commandline}
running 2 tests
I got the value 8
thread 'I got the value 4
tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:20:9
note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Showing Function Output(5/5)}
 \begin{itemize}
  \item \verb|cargo test -- --test-threads=1| \verb|--nocapture| で実行
 \end{itemize}
\begin{commandline}
running 2 tests
test tests::this_test_will_fail ... I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:20:9
note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
FAILED
test tests::this_test_will_pass ... I got the value 4
ok

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Running a Subset of Tests (1/5)}
 \begin{itemize}
  \item 全てのtest suiteを実行すると長時間かかる場合がある
  \item \verb|cargo test| に実行したいテスト名を引数として与えられる
  \item 例として \verb|add_two()| 関数のテストを3つ書く
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Running a Subset of Tests (2/5)}
 \begin{itemize}
  \item \href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6cfe8450229fce550312fdbbf3666b47}
	{(Playground)}
 \end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Running a Subset of Tests (3/5)}
\begin{itemize}
 \item 普通に \verb|cargo test|
\end{itemize}
\begin{commandline}
running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\begin{itemize}
 \item \verb|cargo test one_hundred|
       \begin{itemize}
	\item 2つのテストが実行されていない事が表示される
       \end{itemize}
\end{itemize}
\begin{commandline}
running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; \
2 filtered out
^^^^^^^^^^^^^^
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Running a Subset of Tests (4/5)}
 \begin{itemize}
  \item \verb|cargo test add|
	\begin{itemize}
	 \item テスト名の一部だけ書いてもよく、ヒットしたテストが実行される
	 \item \verb|one_hundred|テストだけ実行されない
	 \item テスト名はモジュール名でも指定できる
	       \begin{itemize}
		\item \verb|cargo test e|とかでも全部かかる
	       \end{itemize}
	\end{itemize}
 \end{itemize}
\begin{commandline}
running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Running a Subset of Tests (5/5)}
 \begin{itemize}
  \item \verb|ignore attribute|
	\begin{itemize}
	 \item \verb|--ignored| オプションを付けたときだけ実行
	\end{itemize}
 \end{itemize}
 {\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}\end{lstlisting}}
\vspace*{-10pt}
\begin{commandline}
% cargo test

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
                                     ^^^^^^^^^
% cargo test -- --ignored

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Test Organization}
 \begin{itemize}
  \item テストは複雑
	\begin{itemize}
	 \item 人によって用語や構成が異なる
	\end{itemize}
  \item Rustコミュニティーで二つのカテゴリの面で
	テストを考える
  \item unit test
	\begin{itemize}
	 \item 小さい単位(モジュールとか)でフォーカスして
	 \item プライベートなインターフェースもテスト
	\end{itemize}
  \item integration test
	\begin{itemize}
	 \item 外部のコードがライブラリを使うようにテスト
	 \item 公開インターフェースのみを他のモジュールと一緒に実行してテスト
	\end{itemize}
  \item テストを書くことは、ライブラリの断片が、別々に、一緒に、
	期待通りに動くことを確認するために重要である
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Unit Tests (1/5)}
 \begin{itemize}
  \item unit testの目的
	\begin{itemize}
	 \item コードの各単位が他のコードから分離できているか
	 \item どの部分が正しく動いて、どの部分が正しく動いていないか
	\end{itemize}
  \item 慣習的には
	\begin{itemize}
	 \item src以下の各ファイルで \texttt{tests} という名前のモジュールを作成
	 \item testsモジュールはテスト関数を持ち、 \verb|cfg(test)| で
	       アノテートされる
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Unit Tests (2/5)}
 \begin{itemize}
  \item \verb|#[cfg(test)]|
	\begin{itemize}
	 \item コンパイラに \verb|cargo test| でのみビルドするよう教える
	 \item コンパイル時間やファイルサイズを抑える
	 \item 後でやるintegration testはsrcに置かないし、
	       \verb|#[cfg(test)]|も付けない
	 \item \verb|cargo new --lib| で生成されるコードにも付いてる
	       \href{https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=ce8ee04d2dcc2311a14efc8090ebda51}
	       {(Playground)}
	 \item モジュール中のヘルパー関数にも適用される
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Unit Tests (3/5)}
 \begin{itemize}
  \item プライベート関数を直接テストするか否か
	\begin{itemize}
	 \item 議論されている
	 \item 他の言語だと、難しかったり、不可能だったり
	 \item Rustのprivacy ruleならできてしまう
	\end{itemize}
  \item プライベート関数 \verb|internal_adder()| で考える
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Unit Tests (4/5)}
 \begin{itemize}
  \item テスト本体
	\begin{itemize}
	 \item \verb|internal_addr()|を直接コール
	 \item \href{https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0d970a840ec7a82730e9a9d71d142e14}
	       {(Playground)}
	\end{itemize}
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Unit Tests (5/5)}
 \begin{itemize}
  \item \verb|internal_addr()| は \verb|pub| が付いていない
	\begin{itemize}
	 \item \verb|tests| は単に別のモジュールであるので
	       \verb|internal_addr()| を \verb|tests| のスコープに持っていける
	\end{itemize}
 \end{itemize}
\begin{commandline}
running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\begin{itemize}
  \item プライベート関数はテストしないべき派の方にも
	特に何も強いません
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Integration Tests (1/11)}
 \begin{itemize}
  \item ライブラリの公開APIを他のコードが使うのと同じようにテストする
	\begin{itemize}
	 \item 目的はライブラリのパーツが、一緒に正しく動くかをテストすること
	 \item 単体では動作するけどintegrateされると問題を起こすことはままある
	 \item integrateされたコードのtest coverageは重要
	\end{itemize}
  \item integration testのためには、まず \texttt{tests} ディレクトリを作る
 \end{itemize}
\end{frame}

\begin{frame}[fragile]{Integration Tests (2/11)}
 \begin{itemize}
  \item \texttt{tests}ディレクトリ
	\begin{itemize}
	 \item プロジェクトの一番上のレベルに作る (\texttt{src}と同じ階層)
	 \item \texttt{cargo} がそこを見て、各ファイルごとにcrateを作る
	\end{itemize}
  \item 単体テストの \texttt{src/lib.rs} をちょっと変更して
	\texttt{tests/integration\_test.rs}にリネーム
 \end{itemize}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
use adder;

#[test]
fn internal() {
    assert_eq!(4, internal_adder(2, 2));
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Integration Tests (3/11)}
 \mbox{}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
use adder;

#[test]
fn internal() {
    assert_eq!(4, internal_adder(2, 2));
}\end{lstlisting}}
\begin{itemize}
 \item 何が変わった?
       \begin{itemize}
	\item \verb|use super::*;| が \verb|use adder;|に
	      \begin{itemize}
	       \item testが別crateであるため
	       \item ライブラリ名は \texttt{adder} にすること(1敗)
	       \item \texttt{Cargo.toml} の \texttt{name} を書けばOK
	      \end{itemize}
	\item \verb|#cfg(test)|がない
	      \begin{itemize}
	       \item \texttt{tests}ディレクトリに置いたことで
		     cargoがそのように扱ってくれる
	      \end{itemize}
	      \pause
	\item Playgroundではできない orz
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Integration Tests (4/11)}
\begin{commandline}
% cargo test
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/adder-1d0dfd1494bab5c6

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-22e1bbc18e3cf744

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Integration Tests (5/11)}
\begin{itemize}
 \item 項目が3つ表示される
       \begin{itemize}
	\item unit test: さきほどまでの
	\item integration test
	\item doc test
       \end{itemize}
 \item integration testは\\
       \texttt{\footnotesize Running target/debug/deps/integration\_test-XXXXXX}\\[6pt]
       の行から始まっている
       \begin{itemize}
	\item その後、各テストの結果が出力され、最後にsummaryが出てくる
	\item そしてdoc testが続く
	\item testsディレクトリに入れたファイル毎にセクションができて結果表示される
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Integration Tests (6/11)}
\begin{itemize}
 \item \texttt{cargo test}への引数で特定のテストを実行
       \begin{itemize}
	\item \verb|--test| オプションを \texttt{cargo} に渡す
	\item \verb|--test| をつけないと、
	      unit, integration, docで該当する関数のみ実行しにいく
       \end{itemize}
\end{itemize}
\begin{commandline}
% cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/integration_test-22e1bbc18e3cf744

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Integration Tests (7/11)}
\begin{itemize}
 \item テスト機能ごとにファイルを分けたい場合
       \begin{itemize}
	\item \texttt{tests}ディレクトリの各ファイルは
	      それぞれ別のcrateとしてコンパイルされる
       \end{itemize}
 \item 別のcrateとして扱うことについて
       \begin{itemize}
	\item ユーザーが実際にcrateを使う場合に近い状態になるので良い
	\item \texttt{src} 以下のファイルとは振舞いを共有できない
	\item ヘルパー関数はChapt. 7で行なったように
	      共有モジュールとしてextractすればよい
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Integration Tests (8/11)}
 \begin{itemize}
  \item 共有モジュール化の例
	\begin{itemize}
	 \item \verb|tests/common.rs| をつくる
	 \item \verb|#[test]| をつけた関数がないので
	       \verb|setup()| は実行されない
	\end{itemize}
 \end{itemize}
\vspace*{-2pt}
 {\scriptsize
 \begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
pub fn setup() {
    // setup code specific to your library's tests would go here
}\end{lstlisting}}
\vspace*{-10pt}
\begin{commandline}
% cargo test
   Compiling adder v0.1.0 (/home/rare/work/slides/RustBook/samples/integration_test2)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running target/debug/deps/adder-1d0dfd1494bab5c6

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-9c75c5df2f50cca9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Integration Tests (9/11)}
 \begin{itemize}
  \item テストの結果表示には出てきてほしくない
	\begin{itemize}
	 \item 慣習的な方法としては
	       \verb|tests/common.rs| $\Rightarrow$ \verb|tests/common/mod.rs|
	       とする
	 \item \texttt{tests}ディレクトリのサブディレクトリは
	       コンパイルされない(\verb|cargo build|のはなし?)し、テスト結果にも表示されない
	\end{itemize}
 \end{itemize}
 \vspace*{-7pt}
\begin{commandline}
% cargo test
Finished dev [unoptimized + debuginfo] target(s) in 0.01s
Running target/debug/deps/adder-1d0dfd1494bab5c6

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

Running target/debug/deps/integration_test-22e1bbc18e3cf744

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
\end{commandline}
\end{frame}

\begin{frame}[fragile]{Integration Tests (10/11)}
\begin{itemize}
 \item \verb|setup()| を使うには?
       \begin{itemize}
	\item 以下のようにモジュールとして使えばよい
	\item \verb|mod common;| は Chapt. 7のときと同じ
	\item \verb|common::setup()| でコールできるようになる
       \end{itemize}
\end{itemize}
{\scriptsize
\begin{lstlisting}[language=Rust,style=boxed,style=colouredRust]
use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}\end{lstlisting}}
\end{frame}

\begin{frame}[fragile]{Integration Tests (11/11)}
\begin{itemize}
 \item \verb|src/main.rs|だけあって\verb|src/libs.rs|が無いbinary crateのテストは?
       \begin{itemize}
	\item \texttt{tests}ディレクトリにintegration testは作れない
	\item \verb|use| をつかって \verb|src/main.rs| で定義されている
	      関数をスコープに持ってこられない
	\item library crateしか他のcrateからは使えない
       \end{itemize}
 \item Rustのプロジェクトでは
       \begin{itemize}
	\item \verb|src/main.rs| からは \verb|src/lib.rs| にある
	      ロジックを単にコールするだけにする
	\item この構成だと重要な機能は \verb|use| で
	      integration testすることができる
	\item \verb|src/main.rs| はライブラリ部分が正しく動けば
	      動くような小さいコードにしておく
       \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary (1/2)}
 \begin{itemize}
  \item Rustのtest feature
	\begin{itemize}
	 \item 期待通りにコードが動作しつづけるために
	       どう機能するべきかを指定する方法を提供
	\end{itemize}
  \item unit test
	\begin{itemize}
	 \item ライブラリの各パーツを別々にテストできる
	 \item privateな実装のテストができる
	\end{itemize}
  \item integration test
	\begin{itemize}
	 \item ライブラリの多くのパーツが一緒に正しく動くかテストできる
	 \item ライブラリの公開APIを実際に使われるのと同じ方法でテストできる
	\end{itemize}
 \end{itemize}
\end{frame}

\begin{frame}{Summary (2/2)}
\begin{itemize}
 \item Rustの型システムやownershipルールは
       いくつかのタイプのバグを防ぐのに役立つ
 \item テストは、期待する振舞いに関連するロジックのバグの
       削減のために依然重要である
\end{itemize}
\pause
\begin{center}
さぁ、このChapterで学んだ内容を\\
これまでのChapterのprojectsに組み込もう!!
\end{center}
\end{frame}

\end{document}
